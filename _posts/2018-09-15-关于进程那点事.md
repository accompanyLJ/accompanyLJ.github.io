一颗物理cpu在同一时刻只能运行一个进程，只有多颗物理cpu才能真正意义上实现多任务。

在Linux上，决定下一个要运行的进程是通过"调度类"(调度程序)来实现的，优先级越低越块被调度类选中，而且优先级只能调高，不能调低。 

**保护现场**：内核可以强制收回cpu使用权，也可以直接抢占当前运行的进程，随着时间的流失，分配给进程使用的cpu时间会用完，用完之后下一个任务进行，当前进程停止，会将临时停止时的运行环境（寄存器中的内容，页表）保存在内核占用的内存中。

**恢复现场**：下次恢复，将原来保存的环境加载到cpu上。cpu百分百=进程使用cpu时间/cpu总时间

**父子进程:**

子进程总是父进程创建，**fork and exec  clone**

**.fork**：复制进程，复制同一个父进程，父子掌握的资源是一样的，内存中的内容，环境变量和变量，PPID就是父进程的PID，**完全独立**。

.exec：不创建新进程的情况下加载新程序（初始化地址空间），完毕后退出环境。

.clone：实现进程，clone和fork一样，共享父进程的某些资源，**不独立于父进程**。

进程是所有者的，如果不是父进程/非root用户kill掉父进程，子进程就会变成僵尸进程。

前台进程：子进程执行时候，父进程会进入睡眠。

后台进程：&  将命令放入后台，立即返回父进程，所以父进程不会睡眠，伪并行执行方式。

进程之间是可以互相通信的，通过管道方式将进程，进程组（PPID一样）

一、bash内置命令：bash内置命令是非常特殊的，父进程不会创建子进程来执行这些命令，而是直接在当前bash进程中执行。但如果将内置命令放在管道后，则此内置命令将和管道左边的进程同属于一个进程组，所以仍然会创建子进程。

二、使用括号()组合一系列命令：例如(ls;date;echo haha)，独立的括号将会开启一个子shell来执行括号内的命令。这种情况等同于情况。

三、source一般用来加载环境配置类脚本。它也不会开启子shell，直接在当前shell中执行调用脚本且执行脚本后不退出当前shell，所以脚本会继承当前已有的变量，且脚本执行完毕后加载的环境变量会粘滞给当前shell，在当前shell生效。

shell> nohup tar rf a.tar.gz /tmp/*.txt &

### SIGHUP 

(1).当控制终端退出时，会向该终端中的进程发送sighup信号，因此该终端上运行的shell进程、其他普通进程以及任务都会收到sighup而导致进程终止。

三种方式可以改变因终端中断发送sighup而导致子进程也被结束的行为：

​	一是使用nohup命令启动进程，它会忽略所有的sighup信号，使得该进程不会随着终端退出而结束；

​	二是将待执行命令放入子shell中并放入后台运行，例如"(sleep 10 &)"；

​	三是使用disown，将任务列表中的任务移除出job table或者直接使用disown -h的功能设置其不接收终端发送的sighup信号。但不管是何种实现方式，终端退出后未被终止的进程将只能挂靠在init/systemd下。

(2).对于daemon类的程序(即服务性进程)，这类程序不依赖于终端(它们的父进程都是Init或systemd)，它们收到sighup信号时会重读配置文件并重新打开日志文件，使得服务程序可以不用重启就可以加载配置文件。

僵尸进程和SIGCHLD

一个编程完善的程序，在子进程终止、退出的时候，会发送SIGCHLD信号给父进程，父进程收到信号就会通知内核清理该子进程相关信息。

在子进程死亡的那一刹那，子进程的状态就是僵尸进程，但因为发出了SIGCHLD信号给父进程，父进程只要收到该信号，子进程就会被清理也就不再是僵尸进程。所以正常情况下，**所有终止的进程都会有一小段时间处于僵尸态**(发送SIGCHLD信号到父进程收到该信号之间)，只不过这种僵尸进程存在**时间极短**(倒霉的僵尸)，几乎是不可被ps或top这类的程序捕捉到的。

如果在特殊情况下，子进程终止了，但父进程没收到SIGCHLD信号，没收到这信号的原因可能是多种的，不管如何，此时子进程已经成了永存的僵尸，能轻易的被ps或top捕捉到。僵尸不倒霉，人类就要倒霉，但是僵尸爸爸并不知道它儿子已经变成了僵尸，因为有僵尸爸爸的掩护，僵尸道长即内核见不到小僵尸，所以也没法收尸。悲催的是，人类能力不足，直接发送信号(如kill)给僵尸进程是无效的，因为僵尸进程本就是终结了的进程，不占用任何运行资源，也收不到信号，只有内核从进程列表中将僵尸进程表项移除才能收尸。

### pkill命令与参数

pkill [-signal][-v] [-P ppid,...][-s pid,...][-U uid,...][-t term,...] [pattern]

选项说明：

-P ppid,... ：匹配PPID为指定值的进程

-s pid,...  ：匹配PID为指定值的进程

-U uid,...  ：匹配UID为指定值的进程，可以使用数值UID，也可以使用用户名称

-t term,... ：匹配给定终端，终端名称不能带上"/dev/"前缀，其实"w"命令获得终端名就满足此处条件了，所以pkill可以直接杀掉整个终端。

-v          ：反向匹配

-signal     ：指定发送的信号，可以是数值也可以是字符代表的信号

-f          ：默认情况下，pgrep/pkill只会匹配进程名。使用-f将匹配命令行

### fuser命令与参数

fuser [-ki][-signal] file/dir

​	-k：找出文件或目录的pid，并试图kill掉该pid。发送的信号是SIGKILL

​	-i：一般和-k一起使用，指的是在kill掉pid之前询问。

​	-signal：发送信号，如-1 -15，如果不写，默认-9，即kill -9

​	不加选项：直接显示出文件或目录的pid

### lsof命令与参数

lsof  /path/to/somefile：显示打开指定文件的所有进程之列表；建议配合grep使用

​	lsof -c string：显示其COMMAND列中包含指定字符(string)的进程所有打开的文件；可多次使用该选项

​	lsof -p PID：查看该进程打开了哪些文件

​	lsof -U：列出套接字类型的文件。一般和其他条件一起使用。如lsof -u root -a -U

​	lsof -u uid/name：显示指定用户的进程打开的文件；可使用脱字符"^"取反，如"lsof -u ^root"将显示非root用户打开的所有文件。

​	lsof +d /DIR/：显示指定目录下被进程打开的文件

​	lsof +D /DIR/：基本功能同上，但lsof会对指定目录进行递归查找，注意这个参数要比grep版本慢

​	lsof -a：按"与"组合多个条件，如lsof -a -c apache -u apache

​	lsof -N：列出所有NFS（网络文件系统）文件

​	lsof -n：不反解IP至HOSTNAME

​	lsof -i：用以显示符合条件的进程情况

​	lsof -i[46][protocol][@host][:service &#124;port

​	46：IPv4或IPv6

​	protocol：TCP or UDP

​	host：host name或ip地址，表示搜索哪台主机上的进程信息

​	service：服务名称(可以不只一个)

​	port：端口号 (可以不只一个)