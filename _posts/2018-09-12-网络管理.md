## Linux数据包处理过程

ip地址是属于内核的，甚至整个TCP/IP栈都属于内核的，包括Ports，只要能和其中一个地址通信，就能和另一个地址通信（这种说法是不准确的，因为存在一个数据包是否丢弃的问题。），不管是否开启了数据包转发功能。

开启转发功能可以使用如下命令：

#echo 1 > /proc/sys/net/ipv4/ip_forward

#sysctl -w net.ipv4.ip_forward=1

当然这是临时修改方法，重启后就失效，要想永久生效还是得写入配置文件中。



## DNS配置文件

/etc/resolv.conf

该文件用于设置DNS指向，以及解析顺序。该文件格式如下： 

domain  domain_name       # 声明本地域名，即解析时自动隐式补齐的域名
search  domain_name_list  # 指定域名搜索顺序(最多6个)，和domain不能共存，若共存了，则后面的行生效
nameserver  IP1           # 设置DNS指向，最多3个
nameserver  IP2
nameserver  IP3        
options timeout:n attempts:n  # 指定解析超时时间(默认5秒)和解析次数(默认2次)



当解析不带点"."的主机名时，如"www"，认为不是fqdn，将自动加上".malong.com"变成解析"www.malong.com"。 

当解析的名称末尾不带点但中间带了点的，如"www.host"，认为是fqdn，将直接解析"www.host"，解析完这个后再解析加上"malong.com"的名称，即再解析"www.host.malong.com"。 

当解析末尾带点的名称时，如"www.host."认为是完整的fqdn，将直接解析"www.host",解析完后直接结束解析，不会再补齐本地域名再解析。  

search关键字的作用和domain是一样的，只不过search同时还暗含域名搜索的顺序 。例如设置search为如下内容： 

search  malongshuai.com longshuai.com mashuai.com

此时若解析"www.host"，将依次解析"www.host","www.host.malongshuai.com"，"www.host.longshuai.com"，"www.host.mashuai.com"。 

## /etc/udev/rules.d/70-persistent-net.rules

这里存储着网卡的规则集，网卡规则集文件是内核自动生成或者写入的，因此清空它不会有任何的影响。

利用虚拟机克隆功能的时候，因为克隆是完整的复制，所以将网卡规则集也一并拷贝了同样的一份，克隆的机器的MAC地址是新生成的，和拷贝的网卡规则集不匹配，引起MAC地址冲突，导致克隆机的网络启动不了，因此可以在克隆前或克隆后清空/etc/udev/rules.d/70-persistent-net.rules文件中的内容可以解决这个问题，CentOS7在克隆虚拟机方面不会出现MAC地址冲突的问题。

## 路由和网关

路由分为：

主机路由：到达目标主机应该怎么走

网络路由：指明某网段怎么走

默认路由：

优先级高低：主机路由>网络路由>默认路由；

优先级比较在同类路由中，先比较子网掩码长度，子网掩码长的路由条目优先级比子网掩码短的优先级高，当子网掩码长度相同的时候比较第二个因素：管理距离（也可以叫做开销metric）。开销小的（metric值小）的优先级比较高。

### route命令

route [add/del][-host/-net/default] [address[/mask]][netmask] [gw][dev]

选项说明：
add/del：增加或删除路由条目
-net：增加或删除的是一条网络路由
-host：增加或删除的是一条主机路由
default：增加或删除的是一条默认路由
netmask：明确使用netmask关键字指定掩码，要可以不使用该选项直接在地址上使用cidr格式的掩码，即IP/MASK。
gw：指定下一跳的地址。要求下一跳地址必须是能到达的，且一般是和本网段直连的接口。
dev：强制将路由条目关联到指定的接口上。一般内核会自动判断路由条目应该关联到哪个网络接口。

网关gw：指定下一跳地址，也就是使用下一个路由器临近本路由的接口作为下一跳；

使用命令配置的路由条目是存不住的，只有写入配置文件才能永久生效。

根据接口创建一个/etc/sysconfig/network-scripts/route-ethX文件来永久保存路由条目

格式：

​	1.DEST via 下一跳地址 

​	2.	ADDRESS#=TARGET 

​		NETMASK#=mask 

​		GATEWAY#=GW    

## TCP协议

### 特性

​	工作在传输层

​	可靠性强

​	半关闭

​	可分段

​	错误检查

​	面向连接协议

​	全双工协议

​	数据恢复，重传

​	确认机制

​	滑动窗口：发送的数据包请求数量

​	拥塞控制

### TCP包头



TCP报文首部

### **TCP报文首部**

1. 源端口和目的端口，各占2个字节，分别写入源端口和目的端口；
2. 序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；
3. 确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；
4. 数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；
5. 保留，占6位，保留今后使用，但目前应都位0；
6. 紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；
7. 确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；
8. 推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；
9. 复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；
10. 同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；
11. 终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；
12. 窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；
13. 检验和，占2字节，校验首部和数据这两部分；
14. 紧急指针，占2字节，指出本报文段中的紧急数据的字节数；
15. 选项，长度可变，定义一些其他的可选的参数。

### TCP的三次握手





**最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器**。

1. TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；
2. TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。
3. TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。
4. TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。
5. 当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 

**为什么TCP客户端最后还要发送一次确认呢？**

主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

假设有这样的一个场景：**客户端发送了第一个请求连接并且没有丢失，只是因为网络的原因导致在节点中滞留了很久**，因为客户端迟迟没有收到确认报文，认为服务器端没有收到发送的报文，因此会再次向服务器端发送相同的报文，此后完成了连接传输了数据，关闭连接。 后来，滞留很久的第一条报文因网络畅通顺利到达服务器端，这就**造成了不必要的资源浪费**。

### TCP的四次挥手



**数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭**。

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗

1. MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
2. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

### 十一种状态

CLOSED 没有任何连接状态 

LISTEN 侦听状态，等待来自远方TCP端口的连接请求 

SYN-SENT 在发送连接请求后，等待对方确认

SYN-RECEIVED 在收到和发送一个连接请求后，等待对方确认 

ESTABLISHED 代表传输连接建立，双方进入数据传送状态 

FIN-WAIT-1 主动关闭,主机已发送关闭连接请求，等待对方确认 

FIN-WAIT-2 主动关闭,主机已收到对方关闭传输连接确认，等待对方发送关闭 传输连接请求 

TIME-WAIT 完成双向传输连接关闭，等待所有分组消失 

CLOSE-WAIT 被动关闭,收到对方发来的关闭连接请求，并已确认 

LAST-ACK 被动关闭,等待最后一个关闭传输连接确认，并等待所有分组消失

CLOSING 双方同时尝试关闭传输连接，等待对方确认    

### TCP连接状态与故障排查

ping在生产环境中，为了避免TCP泛洪攻击，一般是禁用别人ping的响应，所以ping一般作为测试连通性使用。

**/proc/sys/net/ipv4/icmp_echo_ignore_all：禁止ping主机，设置为1**

ping命令后，会接受到对方的反馈信息，包括ip地址和TTL，TTL表示要经过的路由总数，每经过一个路由，TTL数量都会减少1，

网络测试常用命令：

1）traceroute：raceroute 跟踪数据包到达网络主机所经过的路由工具

2）pathping：是一个路由跟踪工具，它将 ping 和 tracert 命令的功能与这两个工具所不提供的其他信息结合起来，综合了二者的功能

pathping www.baidu.com

3）mtr：以结合ping nslookup tracert 来判断网络的相关特性

4) nslookup:用于解析域名，一般用来检测本机的DNS设置是否配置正确。

**服务器端状态如果发现有很多SYN_RCVD状态** ，**则说明收到了SYN Flood的DoS 拒绝服务攻击**

SYN Flood的DoS原理：攻击者使用大量的假IP地址向服务器发送请求，服务器无法判断真假只负责响应请求，但是这些都是虚假的IP地址，服务器根本找不到客户机，这种情况下，服务器会尝试重新发送SYN+ACK的重试，导致消耗巨大的资源。

## 网络接口绑定技术

Bonding 将**多块网卡绑定同一IP地址对外提供服务**，可以实现高可用或者负载均衡。直接给 两块网卡设置同一IP地址是不可以的。通过bonding，虚拟一块网卡对外提供连接， 物理网卡的被修改为相同的MAC地址   。

借助于网卡绑定技术，不仅可以提高网络传输速度，更重要的是，还可以确保在其中一块网卡出现故障时，依然可以正常提供网络服务。假设我们对两块网卡实施了绑定技术，这样在正常工作中它们会共同传输数据，使得网络传输的速度变得更快；而且即使有一块网卡突然出现了故障，另外一块网卡便会立即自动顶替上去，保证数据传输不会中断。

### 工作模式

mode0（平衡负载模式）：平时两块网卡均工作，且自动备援，但需要在与服务器本地网卡相连的交换机设备上进行端口聚合来支持绑定技术。
mode1（自动备援模式）：平时只有一块网卡工作，在它故障后自动替换为另外的网卡。
mode6（平衡负载模式）：平时两块网卡均工作，且自动备援，无须交换机设备提供辅助支持。

### 配置过程

前提：需要两个网卡的模式相同，都不需要填写IP地址。

创建bonding设备的配置文件
/etc/sysconfig/network-scripts/ifcfg-bond0
DEVICE=bond0
BOOTPROTO=none
BONDING_OPTS= “miimon=100 mode=0”

/etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
BOOTPROTO=none
MASTER=bond0
SLAVE=yes
USERCTL=no
查看bond0状态：/proc/net/bonding/bond0

miimon 是用来进行链路监测的。如果miimon=100，那么系统每100ms监测一次链路连接状态，如果有一条线路不通就转入另一条线路。

删除Bond
ifconfig bond0 down 
rmmod bonding    

### nmcli实现bonding 

添加bonding接口
#nmcli con add type bond con-name mybond0 ifname mybond0 mode
active-backup
添加从属接口
#nmcli con add type bond-slave ifname ens7 master mybond0
#nmcli con add type bond-slave ifname ens3 master mybond0
注：如无为从属接口提供连接名，则该名称是接口名称加类型构成
要启动绑定，则必须首先启动从属接口
#nmcli con up bond-slave-eth0
#nmcli con up bond-slave-eth1
启动绑定
#nmcli con up mybond0

### 采用传统命名网卡

使用传统命名方式：
(1) 编辑/etc/default/grub配置文件
GRUB_CMDLINE_LINUX="rhgb quiet **net.ifnames=0**"
或：修改/boot/grub2/grub.cfg
(2) 为grub2生成其配置文件
#grub2-mkconfig -o /etc/grub2.cfg
(3) 重启系统



